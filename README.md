
* Preliminary

    * Introduction
    * Design and Development (Artificial Minds)
    * General and Specific
    * Process = Product
    * Goals for a Product
        * The Tradeoffs
        * Useful
        * Long-lived
        * Reliable
        * Agile
        * Affordable

* Design

    * Composability
        * Complex Is a Bunch of Simple
        * Separation of Concerns
        * Monoliths
        * Dependencies are Expensive
        * Minimizing Hubs
        * Driving Dependencies
        * The Problem with Plugins
        * Configuration is Brittle

    * Productivity
        * Convenience vs. Productivity
        * Investment
        * Convolution and Simplexity
        * Frameworks vs. Libraries
        * Dynamic vs. Static
        * Code Reuse

    * Abstracting Patterns
        * Infinite Dimensions of Patterns
        * MVC vs. Components
        * State and Immutability
        * Imperative vs. Declarative
        * Lazy Abstractions / Reflection
        * Normalization
        * Normalized Complexity

* Development

    * Project Growth
        * Essential Iteration
        * False Investment
        * Solutions that Scale with Complexity
        * Planning vs. Reacting
        * Prototyping vs. Code Reuse

    * Collaboration
        * The Price of Communication
        * Documentation
        * Issue Tracking
        * Standards
        * Ownership and Responsibility
        * Object Oriented Programming

    * Long-lived Projects
        * Commitment
        * Containing Experiments
        * Using the Classics
        * Avoiding Monoliths
        * Dependencies are Expensive Revisited
        * Runtime Environment vs. Development Environment
        * Performance

    * Legacy
        * Backwards Compatibility
        * Versioning
        * Deprecation
        * Legacy Requirements and Product Usage
        * Legacy dependencies

* Programming

    * Code
        * Arbitrary vs. Meaningful
        * The Bottlenecks of Syntax and Symantics
        * Clarity
        * Naming
        * Flexibility
        * Tooling

    * Debugging
        * Step-based debugging
        * Record-based debugging
        * Test-based debugging

    * Testing
        * Varying Requirements for Reliability
        * The Cost and Benefits of Testing
        * Unit Testing vs. Functional Testing
        * Test-driven Development
        * Human Testing vs. Automated Testing
        * Regressive Bugs
        * Automatic Tests


Copyright 2017 By Christopher W. Johnson