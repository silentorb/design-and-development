# Design and Development

### Designing and Developing Elegant Systems

By Christopher W. Johnson

## Table of Contents

* Preliminary

    * Introduction
    * Design and Development (Artificial Minds)
    * General and Specific
    * Process = Product
    * Goals for a Product
        * The Tradeoffs
        * Useful
        * Long-lived
        * Reliable
        * Agile
        * Affordable

* Design

    * [Composability](contents/composability.md)
        * [Separation of Concerns](contents/composability.md#separation-of-concerns)
        * [Hubs](contents/composability.md#hubs)
        * [Dependencies are Expensive](contents/composability.md#dependencies-are-expensive)
        * [Driving Dependencies](contents/composability.md#driving-dependencies)
        * [Plugins](contents/composability.md#plugins)
        * [Modal Parameters](contents/composability.md#modal-parameters)
        * [The Override Pattern](contents/composability.md#the-override-pattern)

    * Productivity
        * Convenience vs. Productivity
        * Investment
        * Convolution and Simplexity
        * Frameworks vs. Libraries
        * Dynamic vs. Static
        * Code Reuse

    * Abstracting Patterns
        * Infinite Dimensions of Patterns
        * Inheritance
        * Interfaces
        * Encapsulation
        * MVC vs. Components
        * State and Immutability
        * Imperative vs. Declarative
        * Lazy Abstractions / Reflection
        * Normalization
        * Normalized Complexity

* Development

    * Project Growth
        * Essential Iteration
        * False Investment
        * Solutions that Scale with Complexity
        * Planning vs. Reacting
        * Prototyping vs. Code Reuse

    * Collaboration
        * The Price of Communication
        * Documentation
        * Issue Tracking
        * Standards
        * Ownership and Responsibility
        * Object Oriented Programming

    * Long-lived Projects
        * Commitment
        * Containing Experiments
        * Using the Classics
        * Avoiding Monoliths
        * Dependencies are Expensive Revisited
        * Runtime Environment vs. Development Environment
        * Performance

    * Legacy
        * Backwards Compatibility
        * Versioning
        * Deprecation
        * Legacy Requirements and Product Usage
        * Legacy dependencies

* Programming

    * Code
        * Arbitrary vs. Meaningful
        * The Bottlenecks of Syntax and Symantics
        * Clarity
        * Naming
        * Flexibility
        * Tooling

    * Debugging
        * Step-based debugging
        * Record-based debugging
        * Test-based debugging

    * Testing
        * Varying Requirements for Reliability
        * The Cost and Benefits of Testing
        * Unit Testing vs. Functional Testing
        * Test-driven Development
        * Human Testing vs. Automated Testing
        * Regressive Bugs
        * Automatic Tests


Copyright 2017 By Christopher W. Johnson